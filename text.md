복습 연습장
기계어는 우리가 일상생활에서 사용하는 언어와는 너무나도 다른 0과 1로 이루어진 이진 코드를 사용한다.
프로그래밍 언어로 작성한 파일을 소스파일이라고 한다. 소스 파일은 컴퓨터가 바로 이해할 수 없기 때문에
컴파일이라는 과정을  통해서 0과 1로 이루어진 기계어 파일로 번역한 후에 컴퓨터에서 사용한다.
프로그래밍 언어로 작성한 파일을 소스파일이라고 한다.
소스파일은 컴퓨터가 바로 이해할 수 없기 때문에 컴파일이라는 과정을 통해서 0과 1로 이우러진 기계어 파일로 번역한 후에 컴퓨터에서 사용한다.

자바로 작성된 프로그램은 모든 운영체제에서 실행 가능하다. 따라서 윈도우에서 개발된 프로그램을 수정하지 않고 바로 리눅스에서도 실행할 수 있다는 장점이 있다.
객체를 만들고 이 객체들을 서로 연결해서 더 큰 프로그램을 완성하는 기법을 객체지향 프로그래밍이라고 한다. 자바는 객체 지향 프로그래밍을 위한 최적의 언어다.
메모리 자동 정리. 자바는 메로리를 자동관리하므로, 개발자는 메모리를 관리하는 수고를 덜고 핵심기능인 코드 작성에 집중할 수 있다.
무료라이브러리 풍부.



기계어: 컴퓨터(운영체제)가 이해하고 실행할 수 있는 0과 1로 이루어진 코드.
프로그래밍 언어: 사람이 기계어를 이해하는 것은 매우 어렵기 때문에 사람의 언어와 기계어의 다리 역할을 한다. 자바, 파이썬 등.
소스파일: 프로그래밍 언어로 작성된 파일을 말한다.

컴파일: 소스파일을 기계어로 번역하는 것을 말한다. 컴파일러가 컴파일을 함.
JDK: 자바개발도구의 줄임말로, 자바로 프로그램을 개발할 수 있는 실행환경과 개발도구 등을 제공한다.
환경변수: 운영체제가 실행하는데 필요한 정볼르 제공해주는 변수를 말한다. 

자바 프로그램을 개발하기 위해서는 우선 파일 확장명이 .java인 텍스트 파일을 생성하고 자바 언어로 코드를 작성해야 한다.
이렇게 만들어진 자바 소스 파일을 컴파일러인 javac 명령어로 컴파일 한다. 컴파일이 성공하면 확장명이 .class인 바이트 코드 파일이 생성된다.

바이트 코드 파일은 완전한 기계어가 아니므로 바로 실행할 수 있는 파일은 아니다. 바이트 코드 파일을 완전한 기계어로 번역해서 실행하려면 java명령어를 사용해야 한다.


바이트코드 파일과 자바 가상 기계
자바프로그램은 완전한 기계어가 아닌, 바이트코드 파일(.class)로 구성된다. 바이트 코드 파일은 운영체제에서 바로 실행할 수 없고, 자바 가상기계라는 번역기가 필요하다.
jvm을 사용하는 이유는 바이트 코드 파일을 다양한 운영체제에서 수정하지 않고 사용할 수 있도록 하기 위함이다. 
javac 명령어로 컴파일된 바이트 코드 파일은 jdk가 설치된 어떠한 운영체제에서도 java 명령어로 동일하게 실행할 수 있다. 각 운영체제의 jvm은 바이트 코드 파일을 해당 운영체제에서 실행 가능한 기계어로 번역해서 실행하기 때문이다.

변수는 값을 저장할 수 있는 메모리의 특정 번지에 붙이는 이름. 프로그램은 변수를 통해 메모리의 특정 번지에 값을 저장하고 읽을 수 있다.

자바에서는 변수에 값이 저장되지 않으면 변수가 생성되지 않음. 선언과 생성은 다른 이야기.
변수초기화: 변수에 최초로 값이 저장될 때 변수 생성.
메소드란 어떤 일을 처리하는 실행문들을 모아놓은 블록.

자바는 정수, 실수 논리값을 저장할 수 있는 기본 타입을 제공한다. 자바가 제공하는 기본 타입은 총 8개이다.
정수에는 byte, char, short, int, long이있고 소수점이 있는 실수를 저장 할 수 있는 타입에는 float, double이 있다. 
그리고 true, false와 같은 논리값을 저장할 수 있는 타입에는 boolean이 있다.
(String은 기본 타입이 아니라 클래스 타입임)

자바에서는 정수연산의 결과는 정수가 됨 그래서 int 1 나누기 int 2하면 0.5가 아니라 0.0으로 나옴


참조타입은 객체(object)의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스를 말함.
기본 타입으로선언된 변수와 참조타입 변수의 차이점은 저장되는 값이다.  기본타입은 실제 값을 변수 안에 저장하지만,
참조타입은 객체의 번지가 저장됨. 


메소드 영역
메소드 영역은 jvm이 시작 할 떄 생성되고 모든 스레드가 공유하는 영역. 메소드 영역에는 코드에서 사용되는 클래스들을 클래스 로더로 읽어 클래스별로
정적 필드와 상수 메소드 코드 생성자 코드 등을 분류해서 저장함.
힙영역
힙역역은 객체와 배열이 생성되는 여역. 여기 에 생성된 객체외 배열은 JVM스택 영역의 변수나 다른 객체의 필드에서 참조함. 만일 참조하는 변수나 필드가 없다면 의미 없는 객체가 되기 때문에 JVM이 이것을 쓰레기로 취급하고 쓰레기 수집기를 실행시켜 자동으로 제거함. 따라서 개발자는 객체를 제거하기 위해 별도의 코드를 작성할 필요가 없음. 사실 자바는 코드로 객체를 직접 제거하는 방법을 제공하지 않음.

new 연산자는 힙 영역에 새로운 객체를 만들 때 사용하는 연산자로 객체 생성 연산자라고 함.


힙영역에 객체
스택영역에 변수
메소드영역에 상수, 메소드 코드, 생서자 코드, 정적 필드.


배열이란 같은 타입의 데이터를 연속된 공간에 나열하고, 각 데이터에 index를 부여해 놓은 자료구조.
1. 배열은 같은 타입의 데이터만 저장할 수 있음
2. 한번 생성된 배열은 길이를 늘리거나 줄일 수 없음.

타입[] 변수 또는 타입 변수[] String[] agrs or string args[]

배열 변수는 참조 변수에 속함. 배열도 객체이므로 힙 영역에 생성되고 배열 변수는 힙 영역의 배열 객체를 참조함.


기본타입 배열은 각 항목에 직접 값을 갖고 있지만, 참조타입(클래스, 인터페이스)배열은 각 항목에 객체의 번지를 갖고 있음.
예를들어 String은 클래스이므로 String[]배열은 각 항목에 문자열이 아니라, String 객체의 번지를 가지고 있음. 즉 String[] 배열은 String객체를 참조함.
==는 객체의 번지를 비교함. 문자열을 비교하려면 equals를  사용해줘야 함.

배열은 한번 생성하면 크기를 변경할 수 없기 때문에 더 많은 저장 공간이 필요하다면 더 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야 한다.
배열 간의 항목 값들을 복사하려면 for문을 사용하거나 system.arraycopy()메소드를 사용해야 한다. 


한정된 값만을 갖는 타입을 열거타입 enumeration type이라고 한다.
 열거타입은 한정된 값인 열거 상수중에서 하나의 상수를 저장하는 타입이다.
 열거 타입을 선언하기 위해서는 먼저열거 타입의 이름을 정하고 해당 이름으로 소스파일을 생성해야 한다. 여거 타입 이름은
 관례적으로 첫 글자를 대문자로 하고 나머지는 소문자로 구성한다.
 
 public enum 키워드는 열거 타입을 선언하기 위한 키워드이며 반드시 소문자로 작성해야 한다.
 
 열거타입을 선언했다면 이제 열거 타입을 사용할 수 있다.
 열거 타입도 하나의 타입이므로 변수를 선언하고 사용해야 한다.
 열거타입 변수;
 Week today;
  열거 타입 변수를 선언했다면 다음과같이 열거 상수를 저장할 수 있따.
  열거 상수는 단독으로 사용할 수 없고 반드시 열거타입.열거상수 형태로 사용된다.
  열거타입 변수 = 열거타입.열거상수;
  열거상수는 객체다. 열거상수는 열거 객체로 생성된다.
  열거타입 변수 today는 스택 영역에 생성된다. today에 저장되는 값은 Week.SUNDAY 열거 상수가 참조하는 객체의 번지이다.
  따라서 열거상수 Week.SUNDAY와 today 변수는 서로 같은 Week 객체를 참조하게 된다.
  
  
  객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의속서을 가지고 있으면서 식별 가능한 것을 말하낟.
  객체 = 속성 + 동작
자바에서는 설계도가 바로 클래스. 클래스에는 객체를 생성하기 위한 메소드가 정의되어 있음. 
클래스로부터 만들어진 객체를 해당 클래스의 인스턴스.
자동차 클래스의 인스턴스 = 자동차 객체
2개 이상의 클래스가 선언된 소스파일을 컴파일하면 
바이트 코드 파일(.class)는 클래스를 선언한 개수만큼 생김.
소스파일은 클래스 선언을 담고 있는 저장 단위 일 뿐, 클래스 자체가 아님.
가급적이면 소스 파일 하나당 동일한 이름의 클래스 하나를 선언하는 것이 좋음.
객체 생성과 클래스 변수
클래스를 선언한 다음, 컴파일을 했다면(이클립스에서는 저장) 객체를 생성할 설계도가 만들어진 셈.
클래스로 부터 객체를 생성하려면 다음고 같이 new 연산자를 사용하면 된다.
new 클래스();
 new는 클래스로부터 객체를 생성시키는 연산자다. 
 new 연산자 뒤에 생성자가 오는데, 생성자는 클래스()형태다.
 new 연산자로 생성된 객체는 힙Heap영역에 생성된다.
 객체는 힙!
 new 연산자는 힙 영역에 객체를 생성시킨다.
 그리고 객체의 주소를 리턴해준다.
 이 주소를 참조 타입 클래스 변수에 저장해두면 변수를 통해 객체를 사용 할 수 있다.
 클래스 변수  = new 클래스();
 
 클래스는 두 가지 용도가 있다. 하나는 라이브러리(API: Application Program Interface)용이고 다른 하나는
 실행용이다. 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다.
 프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리 클래스이고 단 하나가 실행 클래스다.
 실행 클래스는 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할을 한다.
 대부분의 객체 지향 프로그램은 라이브러리와 실행 클래스가 분리되어 있다.
 
 
 클래스의 구성멤버는 필드, 생성자 그리고 메소드다.
 필드는 객체의 고유데이터를 저장하는 곳이다. 선언 형태는 변수와 비슷하지만 필드를 변수라고 부르지는 않는다.
 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다.
 하지만 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.
 생성자는 객체 생성지 초기화를 담당한다. 클래스 이름으로 되어 있고 리턴 타입이 없다.
 오버로딩: 매개 변수를 달리하는 생성자를 여러개 선언하는 것.
 this() 다른 생성자 호출
오버로딩: 많이 싣는 다. 즉 같은 메소드 이름으로 여러기능을 담는다.

클래스는 객체의 설계도. 클래스 멤버는 당연히 객체에도 포함되어 있어야 함.
인스턴스 멤버는 객체마다 가지고 있는 멤버.
정적멤버는 클래스에 위치시키고 객체들이 공유하는 멤버.
인스턴스 멤버는 객체에 소속된 벱어기이 때문에 객체없이는 사용할 수 없음.

정적 static은 '고정된'이란 의미이다.
정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수있는 필드와 메소드다.
정적멤버 = 정적 필드, 정적 메소드
정적 필드와 정적 메소드를 선언하려면 필드와 메소드 선언시 static 키워드를 추가적으로 붙이면 된다.
정적멤버는 클래스에 고정된 멤버이므로 클래스 로더가 바이트코드를(.class)를 로딩해서 메소드 메모리 영역에 적재할 때 
클래스 별로 관리한다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.
정적이냐 인스턴스냐 선언시 판단 지군은
객체마다 가지고 있어야 한다면 인스턴스 필드,
공용의 데이터면 정적 필드로 선언하는 것이 좋다.
( 주로 고정값인, 변하지 않는 데이터)
계산기 클래스에서, 덧셈 뺄셈 기능은 외부의 주어진 매개값들을 가지고 덧셈과 뺄셈을 '수행'하므로 정적 메소드 해도됨.
근데 컬러 바꾸는건, 그 컬러 바꾸는게 인스턴스 필드에도 영향을 미치니까 인스턴스 메소드.

정적멤버는 클래스이름.필드, 클래스이름.메소드로 사용하라 수 있음.
객체참조 변수로도 접근 가능하지만, 정적 요소는 클래스 이름으로 접근하는 것을 권고함.

정적메소드 내에서는 인스턴스 필드, this 이런 정적이지 않은 멤버들에 변형을 가할 수있는 것들을 사용할 수 없음.


가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있음.
그렇게 만들어진 객체를 싱글톤이라 함.

싱글톤 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야 함. 
그래서 생성자 앞에 private 접근 제한자 붙여줌.
싱글톤은 대충 아래와 같은 모양임

public class 클래스 {
	
	//정적 필드
	private static 클래스  singleton new 클래스();
	
	//생성자 앞에 private 붙여서 외부 접근 막음
	private 클래스(){}
	
	//정적 메소드로 정적 필드에서 참조하고 있는 자신의 객체를 리턴 
	static 클래스 getInstance(){
	return singleton;
	}

}

private = 외부접근 금지.
static =  고정된.
final = 최종값.

final은 최종적이라는 뜻을 가지고 있음. 그렇다면 fianl은 최종적인 필드라는 뜻.
final은 초기값이 저장 = 최종값. 더는 바꿀 수 없음.
static은 하나의 고정된인거고
final은 최종이라는 것. 의미가 어떻게 다른지 이해하길 바람!
final 필드 초기값 설정은 두가지임
1. 필드 선언시 초기화 해준다
2. 생성자에서 초기화 해준다.
 
 그러면 상수는 뭐야?
 상수는 static final 고정된 최종값. 즉, 불변값.
 이를 constant. 콘스탄트 = 스태틱파이널. (ex. 원주율  static final double PI = 3.14159;)
 상수는 모두 대문자로 작성하는 것이 관례임.
 
 
 패키지의 물리적 형태는 파일 시스템 폴더다.
 패키지는 소문자로.
 
 접근제한자
 Access Modifier는 말 그대로 접근을 제한하기 위해 사용된다.
 여기서 접근이란 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근을 말한다.
 
 어떤 경우네는 클래스와 인터페이스를 다른 패키지에서 사용하지 못하도록 막을 필요가 있다.
 생성자를 호출하지 못하게(객채생성막기)하거나 멤버를 사용하지 못하도록 막아야 되는 경우 사용한다.
 접근 제한자는 public, protected, private와 같이 세 가지 종류가 있다.
 
 public: 단어 뜻 그대로 외부 클래스가 자유롭게 사용가능하다.
 protected:  같은 패키지 또는 자식 클래스에서 사용가능하다.
 private: 단어 뜻 그대로 외부유출 금지다.
 
 접근제한자 안붙어 있으면 default인데 default는 같은 패키지에 소속된 클래스만 사용가능하다. 자식 ㄴㄴ.
 그니까 public< protected < default< private임.
 클래스를 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발한다면 반드시 public 접근 제한을 갖도록 해야 함.
 인터넷으로 배포되는 라이브러리 클래스도 모두 public 접근 제한을 갖고 있음
 
 일반적으로 객체 지향 프로그래밍에서는 객체의 필드를 객체 외부에서 직접적으로 접근하는 것을 막는다.
 그 이유는 외부에서 마음대로 변경할 경우 객체의 무결성이 깨질 수 있기 때문이다.
 예를 들어 자동차의 속도는 음수가 될 수 없는데, 외부에서 음수로 변경하면 객체의 무결성이 깨진다.
 이를 방지하기 위해 Getter, Setter씀.  그래서 클래스를 선언 할때 가능하다면 필드를 private 선언해서 외부로부터 보호하고,
 필드에대한 Getter, Setter 메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋음.
 
 
 중첩클래스는 클래스 내부에 선언한 클래스를 말함.
 중첩 클래스를 사용하면 두 클래스의 멤버들을 서로 쉽게 접근할 수 있고 , 외부에는 불필요한 관계 클래스를 감춤으로써
 코드의 복잡성을 줄일 수 있다는 장점이 있음.
 
 중첩클래스는 클래스 내부에 선언되는 위치에 따라서 두 가지로 분류됨.
 클래스의 멤버로서 선언되는 중첩크래스를 멤버클래스.
 생성자 또는 메소드 내부에서 선언되는 중첩클래스를 로컬클래스.
 멤버 클래스는(클래스 내부의 클래스) 클래스나 객체가 사용중이라면 언제든지 재사용이 가능함.
 근데 로컬클래스(메소드 내부에 있는 클래스)는 메소드를 실행할 때만 사용되고 메소드가 종료되면 없어짐.
 중첩 클래스도 하나의 클래스이기 때문에 컴파일하면 바이트코드파일(.class)이 별도로 생성됨.
 멤버클래스라면 이렇게. A$B.class
 여기서 A가 바깥클래스임. ㅇㅇ.
 로컬클래스일경우 $1이 포함되서.
 A$1B.class
 로컬클래스는 주로 다음과 같이 비동기 처리를 위해 스레드 객체를 만들 때 사용함. ㅇㅇ.
 
 
 익명객체는 이름이 없는 객체를 말하낟. 익명 객체를 만들려면 어떤 클래스를 상속하거나, 인터페이스를 구현해야한다.
extends or implements. 익명객체는 클래스 이름이 없다.
부모클래스 변수 = new 부모클래스(){}; 이런 형태임.
이 경우 부모 클래스 변수는 이름이 없는 자식객체를 참조한다.

자식클래스가 재사용되지 않고, 오로지 특정 위치에서 사용할 경우라면 자식 클래스를 명시적으로 선언하는 것은 귀찮은 작업이 된다.
이 경우, 익명 자식객체를 생성해서 사용하는 것이 좋은 방법이다.

부모클래스 변수 =  new 부모클래스(매개값, ...){}
부모 클래스를 상속해서 중괄화{}와같이 자식클래스를 선언하라는 뜻이다. 
{}중괄호 내부에는 필드나 메소드를 선언하거나 부모클래스의 메소드를 재정의(오버라이딩)하는 내용을 작성.
일반적으로 재정의 메소드가 많이 나옴. 일반클래스와의 차이점은 생성자를 선언할 수 없다는 것.

 익명구현 객체 생성
 인터페이스 타입의 필드 또는 변수를 선언하고, 구현 객체를 초기값으로 대입하는 경우를 생각해보자.
 
 
 static은 여러개의 인스턴스가 같은 메모리의 값을 공유하기 위해 사용.
아 진작에 강의 들을걸 책으로 공부하는거 말고...
강의가 더 쏙쏙 효율적으로 들어오네...^^ㅎ....


 

인스턴스가 생성될 때 마다 쓰는 동적 메모리 = 힙메모리.( 가비지 컬렉터가 메모리 수거 할 때 소멸됨)
지역변수가 쓰는 메모리 = 스택메모리( 메소드 안의 변수들. 로컬 배리어블). 메소드 호출 끝나면 소멸.
스태틱이나 리터럴등이 생성되는 데이터 영역.( 프로그램이 처음 시작 할 때 상수와 함께 데이터 영역에 생성되고 프로그램이 끝나면 메모리 해제시 소멸됨)

스태틱 메소드 안에 인스턴스 필드(멤버 변수)를 쓰면 안됨. ㅇㅇ.
지역, 인스턴스, 스태틱 변수 각각 생성되는 시기 다름.
지역변수는  해당 메서드가 호출도 스택에 생성되고 메소드 사용 다하면 사라짐.
인스턴스 변수는 new 연산자로 생성 할 때 생성되는 거임 ㅇㅇ.
스태틱 메소드, 스태틱 변수는 생성되지 않아도  사용가능함 ㅇㅇ. 클래스이름으로 직접 호출 가능.





















